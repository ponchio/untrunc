\input texinfo @c -*- texinfo -*-

@settitle avconv Documentation
@titlepage
@center @titlefont{avconv Documentation}
@end titlepage

@top

@contents

@chapter Synopsis

The generic syntax is:

@example
@c man begin SYNOPSIS
avconv [global options] [[infile options][@option{-i} @var{infile}]]... @{[outfile options] @var{outfile}@}...
@c man end
@end example

@chapter Description
@c man begin DESCRIPTION

avconv is a very fast video and audio converter that can also grab from
a live audio/video source. It can also convert between arbitrary sample
rates and resize video on the fly with a high quality polyphase filter.

avconv reads from an arbitrary number of input "files" (which can be regular
files, pipes, network streams, grabbing devices, etc.), specified by the
@code{-i} option, and writes to an arbitrary number of output "files", which are
specified by a plain output filename. Anything found on the command line which
cannot be interpreted as an option is considered to be an output filename.

Each input or output file can in principle contain any number of streams of
different types (video/audio/subtitle/attachment/data). Allowed number and/or
types of streams can be limited by the container format. Selecting, which
streams from which inputs go into output, is done either automatically or with
the @code{-map} option (see the Stream selection chapter).

To refer to input files in options, you must use their indices (0-based). E.g.
the first input file is @code{0}, the second is @code{1} etc. Similarly, streams
within a file are referred to by their indices. E.g. @code{2:3} refers to the
fourth stream in the third input file. See also the Stream specifiers chapter.

As a general rule, options are applied to the next specified
file. Therefore, order is important, and you can have the same
option on the command line multiple times. Each occurrence is
then applied to the next input or output file.
Exceptions from this rule are the global options (e.g. verbosity level),
which should be specified first.

Do not mix input and output files -- first specify all input files, then all
output files. Also do not mix options which belong to different files. All
options apply ONLY to the next input or output file and are reset between files.

@itemize
@item
To set the video bitrate of the output file to 64kbit/s:
@example
avconv -i input.avi -b 64k output.avi
@end example

@item
To force the frame rate of the output file to 24 fps:
@example
avconv -i input.avi -r 24 output.avi
@end example

@item
To force the frame rate of the input file (valid for raw formats only)
to 1 fps and the frame rate of the output file to 24 fps:
@example
avconv -r 1 -i input.m2v -r 24 output.avi
@end example
@end itemize

The format option may be needed for raw input files.

@c man end DESCRIPTION

@chapter Detailed description
@c man begin DETAILED DESCRIPTION

The transcoding process in @command{avconv} for each output can be described by
the following diagram:

@example
 _______              ______________
|       |            |              |
| input |  demuxer   | encoded data |   decoder
| file  | ---------> | packets      | -----+
|_______|            |______________|      |
                                           v
                                       _________
                                      |         |
                                      | decoded |
                                      | frames  |
                                      |_________|
 ________             ______________       |
|        |           |              |      |
| output | <-------- | encoded data | <----+
| file   |   muxer   | packets      |   encoder
|________|           |______________|


@end example

@command{avconv} calls the libavformat library (containing demuxers) to read
input files and get packets containing encoded data from them. When there are
multiple input files, @command{avconv} tries to keep them synchronized by
tracking lowest timestamp on any active input stream.

Encoded packets are then passed to the decoder (unless streamcopy is selected
for the stream, see further for a description). The decoder produces
uncompressed frames (raw video/PCM audio/...) which can be processed further by
filtering (see next section). After filtering the frames are passed to the
encoder, which encodes them and outputs encoded packets again. Finally those are
passed to the muxer, which writes the encoded packets to the output file.

@section Filtering
Before encoding, @command{avconv} can process raw audio and video frames using
filters from the libavfilter library. Several chained filters form a filter
graph.  @command{avconv} distinguishes between two types of filtergraphs -
simple and complex.

@subsection Simple filtergraphs
Simple filtergraphs are those that have exactly one input and output, both of
the same type. In the above diagram they can be represented by simply inserting
an additional step between decoding and encoding:

@example
 _________                        ______________
|         |                      |              |
| decoded |                      | encoded data |
| frames  |\                    /| packets      |
|_________| \                  / |______________|
             \   __________   /
  simple      \ |          | /  encoder
  filtergraph  \| filtered |/
                | frames   |
                |__________|

@end example

Simple filtergraphs are configured with the per-stream @option{-filter} option
(with @option{-vf} and @option{-af} aliases for video and audio respectively).
A simple filtergraph for video can look for example like this:

@example
 _______        _____________        _______        ________
|       |      |             |      |       |      |        |
| input | ---> | deinterlace | ---> | scale | ---> | output |
|_______|      |_____________|      |_______|      |________|

@end example

Note that some filters change frame properties but not frame contents. E.g. the
@code{fps} filter in the example above changes number of frames, but does not
touch the frame contents. Another example is the @code{setpts} filter, which
only sets timestamps and otherwise passes the frames unchanged.

@subsection Complex filtergraphs
Complex filtergraphs are those which cannot be described as simply a linear
processing chain applied to one stream. This is the case e.g. when the graph has
more than one input and/or output, or when output stream type is different from
input. They can be represented with the following diagram:

@example
 _________
|         |
| input 0 |\                    __________
|_________| \                  |          |
             \   _________    /| output 0 |
              \ |         |  / |__________|
 _________     \| complex | /
|         |     |         |/
| input 1 |---->| filter  |\
|_________|     |         | \   __________
               /| graph   |  \ |          |
              / |         |   \| output 1 |
 _________   /  |_________|    |__________|
|         | /
| input 2 |/
|_________|

@end example

Complex filtergraphs are configured with the @option{-filter_complex} option.
Note that this option is global, since a complex filtergraph by its nature
cannot be unambiguously associated with a single stream or file.

A trivial example of a complex filtergraph is the @code{overlay} filter, which
has two video inputs and one video output, containing one video overlaid on top
of the other. Its audio counterpart is the @code{amix} filter.

@section Stream copy
Stream copy is a mode selected by supplying the @code{copy} parameter to the
@option{-codec} option. It makes @command{avconv} omit the decoding and encoding
step for the specified stream, so it does only demuxing and muxing. It is useful
for changing the container format or modifying container-level metadata. The
diagram above will in this case simplify to this:

@example
 _______              ______________            ________
|       |            |              |          |        |
| input |  demuxer   | encoded data |  muxer   | output |
| file  | ---------> | packets      | -------> | file   |
|_______|            |______________|          |________|

@end example

Since there is no decoding or encoding, it is very fast and there is no quality
loss. However it might not work in some cases because of many factors. Applying
filters is obviously also impossible, since filters work on uncompressed data.

@c man end DETAILED DESCRIPTION

@chapter Stream selection
@c man begin STREAM SELECTION

By default avconv tries to pick the "best" stream of each type present in input
files and add them to each output file. For video, this means the highest
resolution, for audio the highest channel count. For subtitle it's simply the
first subtitle stream.

You can disable some of those defaults by using @code{-vn/-an/-sn} options. For
full manual control, use the @code{-map} option, which disables the defaults just
described.

@c man end STREAM SELECTION

@chapter Options
@c man begin OPTIONS

@include avtools-common-opts.texi

@section Main options

@table @option

@item -f @var{fmt} (@emph{input/output})
Force input or output file format. The format is normally autodetected for input
files and guessed from file extension for output files, so this option is not
needed in most cases.

@item -i @var{filename} (@emph{input})
input file name

@item -y (@emph{global})
Overwrite output files without asking.

@item -n (@emph{global})
Immediately exit when output files already exist.

@item -loop @var{number} (@emph{input})
Set number of times input stream shall be looped. Loop 0 means no loop,
loop -1 means infinite loop.

@item -c[:@var{stream_specifier}] @var{codec} (@emph{input/output,per-stream})
@itemx -codec[:@var{stream_specifier}] @var{codec} (@emph{input/output,per-stream})
Select an encoder (when used before an output file) or a decoder (when used
before an input file) for one or more streams. @var{codec} is the name of a
decoder/encoder or a special value @code{copy} (output only) to indicate that
the stream is not to be reencoded.

For example
@example
avconv -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT
@end example
encodes all video streams with libx264 and copies all audio streams.

For each stream, the last matching @code{c} option is applied, so
@example
avconv -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT
@end example
will copy all the streams except the second video, which will be encoded with
libx264, and the 138th audio, which will be encoded with libvorbis.

@item -t @var{duration} (@emph{output})
Stop writing the output after its duration reaches @var{duration}.
@var{duration} may be a number in seconds, or in @code{hh:mm:ss[.xxx]} form.

@item -fs @var{limit_size} (@emph{output})
Set the file size limit.

@item -ss @var{position} (@emph{input/output})
When used as an input option (before @code{-i}), seeks in this input file to
@var{position}. Note the in most formats it is not possible to seek exactly, so
@command{avconv} will seek to the closest seek point before @var{position}.
When transcoding and @option{-accurate_seek} is enabled (the default), this
extra segment between the seek point and @var{position} will be decoded and
discarded. When doing stream copy or when @option{-noaccurate_seek} is used, it
will be preserved.

When used as an output option (before an output filename), decodes but discards
input until the timestamps reach @var{position}.

@var{position} may be either in seconds or in @code{hh:mm:ss[.xxx]} form.

@item -itsoffset @var{offset} (@emph{input})
Set the input time offset in seconds.
@code{[-]hh:mm:ss[.xxx]} syntax is also supported.
The offset is added to the timestamps of the input files.
Specifying a positive offset means that the corresponding
streams are delayed by @var{offset} seconds.

@item -metadata[:metadata_specifier] @var{key}=@var{value} (@emph{output,per-metadata})
Set a metadata key/value pair.

An optional @var{metadata_specifier} may be given to set metadata
on streams or chapters. See @code{-map_metadata} documentation for
details.

This option overrides metadata set with @code{-map_metadata}. It is
also possible to delete metadata by using an empty value.

For example, for setting the title in the output file:
@example
avconv -i in.avi -metadata title="my title" out.flv
@end example

To set the language of the first audio stream:
@example
avconv -i INPUT -metadata:s:a:0 language=eng OUTPUT
@end example

@item -target @var{type} (@emph{output})
Specify target file type (@code{vcd}, @code{svcd}, @code{dvd}, @code{dv},
@code{dv50}). @var{type} may be prefixed with @code{pal-}, @code{ntsc-} or
@code{film-} to use the corresponding standard. All the format options
(bitrate, codecs, buffer sizes) are then set automatically. You can just type:

@example
avconv -i myfile.avi -target vcd /tmp/vcd.mpg
@end example

Nevertheless you can specify additional options as long as you know
they do not conflict with the standard, as in:

@example
avconv -i myfile.avi -target vcd -bf 2 /tmp/vcd.mpg
@end example

@item -dframes @var{number} (@emph{output})
Set the number of data frames to record. This is an obsolete alias for
@code{-frames:d}, which you should use instead.

@item -frames[:@var{stream_specifier}] @var{framecount} (@emph{output,per-stream})
Stop writing to the stream after @var{framecount} frames.

@item -q[:@var{stream_specifier}] @var{q} (@emph{output,per-stream})
@itemx -qscale[:@var{stream_specifier}] @var{q} (@emph{output,per-stream})
Use fixed quality scale (VBR). The meaning of @var{q} is
codec-dependent.

@item -b[:@var{stream_specifier}] @var{bitrate} (@emph{output,per-stream})
Set the stream bitrate in bits per second. When transcoding, this tells the
encoder to use the specified bitrate for the encoded stream.

For streamcopy, this provides a hint to the muxer about the bitrate of the input
stream.

@item -filter[:@var{stream_specifier}] @var{filter_graph} (@emph{output,per-stream})
@var{filter_graph} is a description of the filter graph to apply to
the stream. Use @code{-filters} to show all the available filters
(including also sources and sinks).

See also the @option{-filter_complex} option if you want to create filter graphs
with multiple inputs and/or outputs.

@item -filter_script[:@var{stream_specifier}] @var{filename} (@emph{output,per-stream})
This option is similar to @option{-filter}, the only difference is that its
argument is the name of the file from which a filtergraph description is to be
read.

@item -pre[:@var{stream_specifier}] @var{preset_name} (@emph{output,per-stream})
Specify the preset for matching stream(s).

@item -stats (@emph{global})
Print encoding progress/statistics. On by default.

@item -attach @var{filename} (@emph{output})
Add an attachment to the output file. This is supported by a few formats
like Matroska for e.g. fonts used in rendering subtitles. Attachments
are implemented as a specific type of stream, so this option will add
a new stream to the file. It is then possible to use per-stream options
on this stream in the usual way. Attachment streams created with this
option will be created after all the other streams (i.e. those created
with @code{-map} or automatic mappings).

Note that for Matroska you also have to set the mimetype metadata tag:
@example
avconv -i INPUT -attach DejaVuSans.ttf -metadata:s:2 mimetype=application/x-truetype-font out.mkv
@end example
(assuming that the attachment stream will be third in the output file).

@item -dump_attachment[:@var{stream_specifier}] @var{filename} (@emph{input,per-stream})
Extract the matching attachment stream into a file named @var{filename}. If
@var{filename} is empty, then the value of the @code{filename} metadata tag
will be used.

E.g. to extract the first attachment to a file named 'out.ttf':
@example
avconv -dump_attachment:t:0 out.ttf INPUT
@end example
To extract all attachments to files determined by the @code{filename} tag:
@example
avconv -dump_attachment:t "" INPUT
@end example

Technical note -- attachments are implemented as codec extradata, so this
option can actually be used to extract extradata from any stream, not just
attachments.

@item -noautorotate
Disable automatically rotating video based on file metadata.

@end table

@section Video Options

@table @option
@item -vframes @var{number} (@emph{output})
Set the number of video frames to record. This is an obsolete alias for
@code{-frames:v}, which you should use instead.
@item -r[:@var{stream_specifier}] @var{fps} (@emph{input/output,per-stream})
Set frame rate (Hz value, fraction or abbreviation).

As an input option, ignore any timestamps stored in the file and instead
generate timestamps assuming constant frame rate @var{fps}.

As an output option, duplicate or drop input frames to achieve constant output
frame rate @var{fps} (note that this actually causes the @code{fps} filter to be
inserted to the end of the corresponding filtergraph).

@item -s[:@var{stream_specifier}] @var{size} (@emph{input/output,per-stream})
Set frame size.

As an input option, this is a shortcut for the @option{video_size} private
option, recognized by some demuxers for which the frame size is either not
stored in the file or is configurable -- e.g. raw video or video grabbers.

As an output option, this inserts the @code{scale} video filter to the
@emph{end} of the corresponding filtergraph. Please use the @code{scale} filter
directly to insert it at the beginning or some other place.

The format is @samp{wxh} (default - same as source).  The following
abbreviations are recognized:
@table @samp
@item sqcif
128x96
@item qcif
176x144
@item cif
352x288
@item 4cif
704x576
@item 16cif
1408x1152
@item qqvga
160x120
@item qvga
320x240
@item vga
640x480
@item svga
800x600
@item xga
1024x768
@item uxga
1600x1200
@item qxga
2048x1536
@item sxga
1280x1024
@item qsxga
2560x2048
@item hsxga
5120x4096
@item wvga
852x480
@item wxga
1366x768
@item wsxga
1600x1024
@item wuxga
1920x1200
@item woxga
2560x1600
@item wqsxga
3200x2048
@item wquxga
3840x2400
@item whsxga
6400x4096
@item whuxga
7680x4800
@item cga
320x200
@item ega
640x350
@item hd480
852x480
@item hd720
1280x720
@item hd1080
1920x1080
@item 2kdci
2048x1080
@item 4kdci
4096x2160
@item uhd2160
3840x2160
@item uhd4320
7680x4320
@end table

@item -aspect[:@var{stream_specifier}] @var{aspect} (@emph{output,per-stream})
Set the video display aspect ratio specified by @var{aspect}.

@var{aspect} can be a floating point number string, or a string of the
form @var{num}:@var{den}, where @var{num} and @var{den} are the
numerator and denominator of the aspect ratio. For example "4:3",
"16:9", "1.3333", and "1.7777" are valid argument values.

@item -vn (@emph{output})
Disable video recording.

@item -vcodec @var{codec} (@emph{output})
Set the video codec. This is an alias for @code{-codec:v}.

@item -pass[:@var{stream_specifier}] @var{n} (@emph{output,per-stream})
Select the pass number (1 or 2). It is used to do two-pass
video encoding. The statistics of the video are recorded in the first
pass into a log file (see also the option -passlogfile),
and in the second pass that log file is used to generate the video
at the exact requested bitrate.
On pass 1, you may just deactivate audio and set output to null,
examples for Windows and Unix:
@example
avconv -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y NUL
avconv -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y /dev/null
@end example

@item -passlogfile[:@var{stream_specifier}] @var{prefix} (@emph{output,per-stream})
Set two-pass log file name prefix to @var{prefix}, the default file name
prefix is ``av2pass''. The complete file name will be
@file{PREFIX-N.log}, where N is a number specific to the output
stream.

@item -vf @var{filter_graph} (@emph{output})
@var{filter_graph} is a description of the filter graph to apply to
the input video.
Use the option "-filters" to show all the available filters (including
also sources and sinks).  This is an alias for @code{-filter:v}.

@end table

@section Advanced Video Options

@table @option
@item -pix_fmt[:@var{stream_specifier}] @var{format} (@emph{input/output,per-stream})
Set pixel format. Use @code{-pix_fmts} to show all the supported
pixel formats.
@item -sws_flags @var{flags} (@emph{input/output})
Set SwScaler flags.
@item -vdt @var{n}
Discard threshold.

@item -rc_override[:@var{stream_specifier}] @var{override} (@emph{output,per-stream})
rate control override for specific intervals

@item -vstats
Dump video coding statistics to @file{vstats_HHMMSS.log}.
@item -vstats_file @var{file}
Dump video coding statistics to @var{file}.
@item -top[:@var{stream_specifier}] @var{n} (@emph{output,per-stream})
top=1/bottom=0/auto=-1 field first
@item -dc @var{precision}
Intra_dc_precision.
@item -vtag @var{fourcc/tag} (@emph{output})
Force video tag/fourcc. This is an alias for @code{-tag:v}.
@item -qphist (@emph{global})
Show QP histogram.
@item -force_key_frames[:@var{stream_specifier}] @var{time}[,@var{time}...] (@emph{output,per-stream})
Force key frames at the specified timestamps, more precisely at the first
frames after each specified time.
This option can be useful to ensure that a seek point is present at a
chapter mark or any other designated place in the output file.
The timestamps must be specified in ascending order.

@item -copyinkf[:@var{stream_specifier}] (@emph{output,per-stream})
When doing stream copy, copy also non-key frames found at the
beginning.

@item -init_hw_device @var{type}[=@var{name}][:@var{device}[,@var{key=value}...]]
Initialise a new hardware device of type @var{type} called @var{name}, using the
given device parameters.
If no name is specified it will receive a default name of the form "@var{type}%d".

The meaning of @var{device} and the following arguments depends on the
device type:
@table @option

@item cuda
@var{device} is the number of the CUDA device.

@item dxva2
@var{device} is the number of the Direct3D 9 display adapter.

@item vaapi
@var{device} is either an X11 display name or a DRM render node.
If not specified, it will attempt to open the default X11 display (@emph{$DISPLAY})
and then the first DRM render node (@emph{/dev/dri/renderD128}).

@item vdpau
@var{device} is an X11 display name.
If not specified, it will attempt to open the default X11 display (@emph{$DISPLAY}).

@item qsv
@var{device} selects a value in @samp{MFX_IMPL_*}. Allowed values are:
@table @option
@item auto
@item sw
@item hw
@item auto_any
@item hw_any
@item hw2
@item hw3
@item hw4
@end table
If not specified, @samp{auto_any} is used.
(Note that it may be easier to achieve the desired result for QSV by creating the
platform-appropriate subdevice (@samp{dxva2} or @samp{vaapi}) and then deriving a
QSV device from that.)

@end table

@item -init_hw_device @var{type}[=@var{name}]@@@var{source}
Initialise a new hardware device of type @var{type} called @var{name},
deriving it from the existing device with the name @var{source}.

@item -init_hw_device list
List all hardware device types supported in this build of avconv.

@item -filter_hw_device @var{name}
Pass the hardware device called @var{name} to all filters in any filter graph.
This can be used to set the device to upload to with the @code{hwupload} filter,
or the device to map to with the @code{hwmap} filter.  Other filters may also
make use of this parameter when they require a hardware device.  Note that this
is typically only required when the input is not already in hardware frames -
when it is, filters will derive the device they require from the context of the
frames they receive as input.

This is a global setting, so all filters will receive the same device.

Do not use this option in scripts that should remain functional in future
avconv versions.

@item -hwaccel[:@var{stream_specifier}] @var{hwaccel} (@emph{input,per-stream})
Use hardware acceleration to decode the matching stream(s). The allowed values
of @var{hwaccel} are:
@table @option
@item none
Do not use any hardware acceleration (the default).

@item auto
Automatically select the hardware acceleration method.

@item vda
Use Apple VDA hardware acceleration.

@item vdpau
Use VDPAU (Video Decode and Presentation API for Unix) hardware acceleration.

@item dxva2
Use DXVA2 (DirectX Video Acceleration) hardware acceleration.

@item vaapi
Use VAAPI (Video Acceleration API) hardware acceleration.

@item qsv
Use the Intel QuickSync Video acceleration for video transcoding.

Unlike most other values, this option does not enable accelerated decoding (that
is used automatically whenever a qsv decoder is selected), but accelerated
transcoding, without copying the frames into the system memory.

For it to work, both the decoder and the encoder must support QSV acceleration
and no filters must be used.
@end table

This option has no effect if the selected hwaccel is not available or not
supported by the chosen decoder.

Note that most acceleration methods are intended for playback and will not be
faster than software decoding on modern CPUs. Additionally, @command{avconv}
will usually need to copy the decoded frames from the GPU memory into the system
memory, resulting in further performance loss. This option is thus mainly
useful for testing.

@item -hwaccel_device[:@var{stream_specifier}] @var{hwaccel_device} (@emph{input,per-stream})
Select a device to use for hardware acceleration.

This option only makes sense when the @option{-hwaccel} option is also specified.
It can either refer to an existing device created with @option{-init_hw_device}
by name, or it can create a new device as if
@samp{-init_hw_device} @var{type}:@var{hwaccel_device}
were called immediately before.

@item -hwaccels
List all hardware acceleration methods supported in this build of avconv.

@end table

@section Audio Options

@table @option
@item -aframes @var{number} (@emph{output})
Set the number of audio frames to record. This is an obsolete alias for
@code{-frames:a}, which you should use instead.
@item -ar[:@var{stream_specifier}] @var{freq} (@emph{input/output,per-stream})
Set the audio sampling frequency. For output streams it is set by
default to the frequency of the corresponding input stream. For input
streams this option only makes sense for audio grabbing devices and raw
demuxers and is mapped to the corresponding demuxer options.
@item -aq @var{q} (@emph{output})
Set the audio quality (codec-specific, VBR). This is an alias for -q:a.
@item -ac[:@var{stream_specifier}] @var{channels} (@emph{input/output,per-stream})
Set the number of audio channels. For output streams it is set by
default to the number of input audio channels. For input streams
this option only makes sense for audio grabbing devices and raw demuxers
and is mapped to the corresponding demuxer options.
@item -an (@emph{output})
Disable audio recording.
@item -acodec @var{codec} (@emph{input/output})
Set the audio codec. This is an alias for @code{-codec:a}.
@item -sample_fmt[:@var{stream_specifier}] @var{sample_fmt} (@emph{output,per-stream})
Set the audio sample format. Use @code{-sample_fmts} to get a list
of supported sample formats.
@item -af @var{filter_graph} (@emph{output})
@var{filter_graph} is a description of the filter graph to apply to
the input audio.
Use the option "-filters" to show all the available filters (including
also sources and sinks).  This is an alias for @code{-filter:a}.
@end table

@section Advanced Audio options:

@table @option
@item -atag @var{fourcc/tag} (@emph{output})
Force audio tag/fourcc. This is an alias for @code{-tag:a}.
@end table

@section Subtitle options:

@table @option
@item -scodec @var{codec} (@emph{input/output})
Set the subtitle codec. This is an alias for @code{-codec:s}.
@item -sn (@emph{output})
Disable subtitle recording.
@end table

@section Advanced options

@table @option
@item -map [-]@var{input_file_id}[:@var{stream_specifier}][,@var{sync_file_id}[:@var{stream_specifier}]] | @var{[linklabel]} (@emph{output})

Designate one or more input streams as a source for the output file. Each input
stream is identified by the input file index @var{input_file_id} and
the input stream index @var{input_stream_id} within the input
file. Both indices start at 0. If specified,
@var{sync_file_id}:@var{stream_specifier} sets which input stream
is used as a presentation sync reference.

The first @code{-map} option on the command line specifies the
source for output stream 0, the second @code{-map} option specifies
the source for output stream 1, etc.

A @code{-} character before the stream identifier creates a "negative" mapping.
It disables matching streams from already created mappings.

An alternative @var{[linklabel]} form will map outputs from complex filter
graphs (see the @option{-filter_complex} option) to the output file.
@var{linklabel} must correspond to a defined output link label in the graph.

For example, to map ALL streams from the first input file to output
@example
avconv -i INPUT -map 0 output
@end example

For example, if you have two audio streams in the first input file,
these streams are identified by "0:0" and "0:1". You can use
@code{-map} to select which streams to place in an output file. For
example:
@example
avconv -i INPUT -map 0:1 out.wav
@end example
will map the input stream in @file{INPUT} identified by "0:1" to
the (single) output stream in @file{out.wav}.

For example, to select the stream with index 2 from input file
@file{a.mov} (specified by the identifier "0:2"), and stream with
index 6 from input @file{b.mov} (specified by the identifier "1:6"),
and copy them to the output file @file{out.mov}:
@example
avconv -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov
@end example

To select all video and the third audio stream from an input file:
@example
avconv -i INPUT -map 0:v -map 0:a:2 OUTPUT
@end example

To map all the streams except the second audio, use negative mappings
@example
avconv -i INPUT -map 0 -map -0:a:1 OUTPUT
@end example

To pick the English audio stream:
@example
avconv -i INPUT -map 0:m:language:eng OUTPUT
@end example

Note that using this option disables the default mappings for this output file.

@item -map_metadata[:@var{metadata_spec_out}] @var{infile}[:@var{metadata_spec_in}] (@emph{output,per-metadata})
Set metadata information of the next output file from @var{infile}. Note that
those are file indices (zero-based), not filenames.
Optional @var{metadata_spec_in/out} parameters specify, which metadata to copy.
A metadata specifier can have the following forms:
@table @option
@item @var{g}
global metadata, i.e. metadata that applies to the whole file

@item @var{s}[:@var{stream_spec}]
per-stream metadata. @var{stream_spec} is a stream specifier as described
in the @ref{Stream specifiers} chapter. In an input metadata specifier, the first
matching stream is copied from. In an output metadata specifier, all matching
streams are copied to.

@item @var{c}:@var{chapter_index}
per-chapter metadata. @var{chapter_index} is the zero-based chapter index.

@item @var{p}:@var{program_index}
per-program metadata. @var{program_index} is the zero-based program index.
@end table
If metadata specifier is omitted, it defaults to global.

By default, global metadata is copied from the first input file,
per-stream and per-chapter metadata is copied along with streams/chapters. These
default mappings are disabled by creating any mapping of the relevant type. A negative
file index can be used to create a dummy mapping that just disables automatic copying.

For example to copy metadata from the first stream of the input file to global metadata
of the output file:
@example
avconv -i in.ogg -map_metadata 0:s:0 out.mp3
@end example

To do the reverse, i.e. copy global metadata to all audio streams:
@example
avconv -i in.mkv -map_metadata:s:a 0:g out.mkv
@end example
Note that simple @code{0} would work as well in this example, since global
metadata is assumed by default.

@item -map_chapters @var{input_file_index} (@emph{output})
Copy chapters from input file with index @var{input_file_index} to the next
output file. If no chapter mapping is specified, then chapters are copied from
the first input file with at least one chapter. Use a negative file index to
disable any chapter copying.
@item -debug
Print specific debug info.
@item -benchmark (@emph{global})
Show benchmarking information at the end of an encode.
Shows CPU time used and maximum memory consumption.
Maximum memory consumption is not supported on all systems,
it will usually display as 0 if not supported.
@item -timelimit @var{duration} (@emph{global})
Exit after avconv has been running for @var{duration} seconds.
@item -dump (@emph{global})
Dump each input packet to stderr.
@item -hex (@emph{global})
When dumping packets, also dump the payload.
@item -re (@emph{input})
Read input at native frame rate. Mainly used to simulate a grab device
or live input stream (e.g. when reading from a file). Should not be used
with actual grab devices or live input streams (where it can cause packet
loss).
@item -vsync @var{parameter}
Video sync method.

@table @option
@item passthrough
Each frame is passed with its timestamp from the demuxer to the muxer.
@item cfr
Frames will be duplicated and dropped to achieve exactly the requested
constant framerate.
@item vfr
Frames are passed through with their timestamp or dropped so as to
prevent 2 frames from having the same timestamp.
@item auto
Chooses between 1 and 2 depending on muxer capabilities. This is the
default method.
@end table

With -map you can select from which stream the timestamps should be
taken. You can leave either video or audio unchanged and sync the
remaining stream(s) to the unchanged one.

@item -async @var{samples_per_second}
Audio sync method. "Stretches/squeezes" the audio stream to match the timestamps,
the parameter is the maximum samples per second by which the audio is changed.
-async 1 is a special case where only the start of the audio stream is corrected
without any later correction.
This option has been deprecated. Use the @code{asyncts} audio filter instead.
@item -copyts
Copy timestamps from input to output.
@item -copytb
Copy input stream time base from input to output when stream copying.
@item -shortest (@emph{output})
Finish encoding when the shortest input stream ends.
@item -dts_delta_threshold
Timestamp discontinuity delta threshold.
@item -muxdelay @var{seconds} (@emph{input})
Set the maximum demux-decode delay.
@item -muxpreload @var{seconds} (@emph{input})
Set the initial demux-decode delay.
@item -streamid @var{output-stream-index}:@var{new-value} (@emph{output})
Assign a new stream-id value to an output stream. This option should be
specified prior to the output filename to which it applies.
For the situation where multiple output files exist, a streamid
may be reassigned to a different value.

For example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for
an output mpegts file:
@example
avconv -i infile -streamid 0:33 -streamid 1:36 out.ts
@end example

@item -bsf[:@var{stream_specifier}] @var{bitstream_filters} (@emph{output,per-stream})
Set bitstream filters for matching streams. @var{bitstream_filters} is
a comma-separated list of bitstream filters. Use the @code{-bsfs} option
to get the list of bitstream filters.
@example
avconv -i h264.mp4 -c:v copy -bsf:v h264_mp4toannexb -an out.h264
@end example
@example
avconv -i file.mov -an -vn -bsf:s mov2textsub -c:s copy -f rawvideo sub.txt
@end example

@item -tag[:@var{stream_specifier}] @var{codec_tag} (@emph{input/output,per-stream})
Force a tag/fourcc for matching streams.

@item -filter_complex @var{filtergraph} (@emph{global})
Define a complex filter graph, i.e. one with arbitrary number of inputs and/or
outputs. For simple graphs -- those with one input and one output of the same
type -- see the @option{-filter} options. @var{filtergraph} is a description of
the filter graph, as described in @ref{Filtergraph syntax}.

Input link labels must refer to input streams using the
@code{[file_index:stream_specifier]} syntax (i.e. the same as @option{-map}
uses). If @var{stream_specifier} matches multiple streams, the first one will be
used. An unlabeled input will be connected to the first unused input stream of
the matching type.

Output link labels are referred to with @option{-map}. Unlabeled outputs are
added to the first output file.

Note that with this option it is possible to use only lavfi sources without
normal input files.

For example, to overlay an image over video
@example
avconv -i video.mkv -i image.png -filter_complex '[0:v][1:v]overlay[out]' -map
'[out]' out.mkv
@end example
Here @code{[0:v]} refers to the first video stream in the first input file,
which is linked to the first (main) input of the overlay filter. Similarly the
first video stream in the second input is linked to the second (overlay) input
of overlay.

Assuming there is only one video stream in each input file, we can omit input
labels, so the above is equivalent to
@example
avconv -i video.mkv -i image.png -filter_complex 'overlay[out]' -map
'[out]' out.mkv
@end example

Furthermore we can omit the output label and the single output from the filter
graph will be added to the output file automatically, so we can simply write
@example
avconv -i video.mkv -i image.png -filter_complex 'overlay' out.mkv
@end example

To generate 5 seconds of pure red video using lavfi @code{color} source:
@example
avconv -filter_complex 'color=red' -t 5 out.mkv
@end example

@item -filter_complex_script @var{filename} (@emph{global})
This option is similar to @option{-filter_complex}, the only difference is that
its argument is the name of the file from which a complex filtergraph
description is to be read.

@item -accurate_seek (@emph{input})
This option enables or disables accurate seeking in input files with the
@option{-ss} option. It is enabled by default, so seeking is accurate when
transcoding. Use @option{-noaccurate_seek} to disable it, which may be useful
e.g. when copying some streams and transcoding the others.

@item -max_muxing_queue_size @var{packets} (@emph{output,per-stream})
When transcoding audio and/or video streams, avconv will not begin writing into
the output until it has one packet for each such stream. While waiting for that
to happen, packets for other streams are buffered. This option sets the size of
this buffer, in packets, for the matching output stream.

The default value of this option should be high enough for most uses, so only
touch this option if you are sure that you need it.

@end table
@c man end OPTIONS

@chapter Tips
@c man begin TIPS

@itemize
@item
For streaming at very low bitrate application, use a low frame rate
and a small GOP size. This is especially true for RealVideo where
the Linux player does not seem to be very fast, so it can miss
frames. An example is:

@example
avconv -g 3 -r 3 -t 10 -b 50k -s qcif -f rv10 /tmp/b.rm
@end example

@item
The parameter 'q' which is displayed while encoding is the current
quantizer. The value 1 indicates that a very good quality could
be achieved. The value 31 indicates the worst quality. If q=31 appears
too often, it means that the encoder cannot compress enough to meet
your bitrate. You must either increase the bitrate, decrease the
frame rate or decrease the frame size.

@item
If your computer is not fast enough, you can speed up the
compression at the expense of the compression ratio. You can use
'-me zero' to speed up motion estimation, and '-g 0' to disable
motion estimation completely (you have only I-frames, which means it
is about as good as JPEG compression).

@item
To have very low audio bitrates, reduce the sampling frequency
(down to 22050 Hz for MPEG audio, 22050 or 11025 for AC-3).

@item
To have a constant quality (but a variable bitrate), use the option
'-qscale n' when 'n' is between 1 (excellent quality) and 31 (worst
quality).

@end itemize
@c man end TIPS

@chapter Examples
@c man begin EXAMPLES

@section Preset files

A preset file contains a sequence of @var{option=value} pairs, one for
each line, specifying a sequence of options which can be specified also on
the command line. Lines starting with the hash ('#') character are ignored and
are used to provide comments. Empty lines are also ignored. Check the
@file{presets} directory in the Libav source tree for examples.

Preset files are specified with the @code{pre} option, this option takes a
preset name as input.  Avconv searches for a file named @var{preset_name}.avpreset in
the directories @file{$AVCONV_DATADIR} (if set), and @file{$HOME/.avconv}, and in
the data directory defined at configuration time (usually @file{$PREFIX/share/avconv})
in that order.  For example, if the argument is @code{libx264-max}, it will
search for the file @file{libx264-max.avpreset}.

@section Video and Audio grabbing

If you specify the input format and device then avconv can grab video
and audio directly.

@example
avconv -f oss -i /dev/dsp -f video4linux2 -i /dev/video0 /tmp/out.mpg
@end example

Note that you must activate the right video source and channel before
launching avconv with any TV viewer such as
@uref{http://linux.bytesex.org/xawtv/, xawtv} by Gerd Knorr. You also
have to set the audio recording levels correctly with a
standard mixer.

@section X11 grabbing

Grab the X11 display with avconv via

@example
avconv -f x11grab -s cif -r 25 -i :0.0 /tmp/out.mpg
@end example

0.0 is display.screen number of your X11 server, same as
the DISPLAY environment variable.

@example
avconv -f x11grab -s cif -r 25 -i :0.0+10,20 /tmp/out.mpg
@end example

0.0 is display.screen number of your X11 server, same as the DISPLAY environment
variable. 10 is the x-offset and 20 the y-offset for the grabbing.

@section Video and Audio file format conversion

Any supported file format and protocol can serve as input to avconv:

Examples:
@itemize
@item
You can use YUV files as input:

@example
avconv -i /tmp/test%d.Y /tmp/out.mpg
@end example

It will use the files:
@example
/tmp/test0.Y, /tmp/test0.U, /tmp/test0.V,
/tmp/test1.Y, /tmp/test1.U, /tmp/test1.V, etc...
@end example

The Y files use twice the resolution of the U and V files. They are
raw files, without header. They can be generated by all decent video
decoders. You must specify the size of the image with the @option{-s} option
if avconv cannot guess it.

@item
You can input from a raw YUV420P file:

@example
avconv -i /tmp/test.yuv /tmp/out.avi
@end example

test.yuv is a file containing raw YUV planar data. Each frame is composed
of the Y plane followed by the U and V planes at half vertical and
horizontal resolution.

@item
You can output to a raw YUV420P file:

@example
avconv -i mydivx.avi hugefile.yuv
@end example

@item
You can set several input files and output files:

@example
avconv -i /tmp/a.wav -s 640x480 -i /tmp/a.yuv /tmp/a.mpg
@end example

Converts the audio file a.wav and the raw YUV video file a.yuv
to MPEG file a.mpg.

@item
You can also do audio and video conversions at the same time:

@example
avconv -i /tmp/a.wav -ar 22050 /tmp/a.mp2
@end example

Converts a.wav to MPEG audio at 22050 Hz sample rate.

@item
You can encode to several formats at the same time and define a
mapping from input stream to output streams:

@example
avconv -i /tmp/a.wav -map 0:a -b 64k /tmp/a.mp2 -map 0:a -b 128k /tmp/b.mp2
@end example

Converts a.wav to a.mp2 at 64 kbits and to b.mp2 at 128 kbits. '-map
file:index' specifies which input stream is used for each output
stream, in the order of the definition of output streams.

@item
You can transcode decrypted VOBs:

@example
avconv -i snatch_1.vob -f avi -c:v mpeg4 -b:v 800k -g 300 -bf 2 -c:a libmp3lame -b:a 128k snatch.avi
@end example

This is a typical DVD ripping example; the input is a VOB file, the
output an AVI file with MPEG-4 video and MP3 audio. Note that in this
command we use B-frames so the MPEG-4 stream is DivX5 compatible, and
GOP size is 300 which means one intra frame every 10 seconds for 29.97fps
input video. Furthermore, the audio stream is MP3-encoded so you need
to enable LAME support by passing @code{--enable-libmp3lame} to configure.
The mapping is particularly useful for DVD transcoding
to get the desired audio language.

NOTE: To see the supported input formats, use @code{avconv -formats}.

@item
You can extract images from a video, or create a video from many images:

For extracting images from a video:
@example
avconv -i foo.avi -r 1 -s WxH -f image2 foo-%03d.jpeg
@end example

This will extract one video frame per second from the video and will
output them in files named @file{foo-001.jpeg}, @file{foo-002.jpeg},
etc. Images will be rescaled to fit the new WxH values.

If you want to extract just a limited number of frames, you can use the
above command in combination with the @code{-frames:v} or @code{-t} option,
or in combination with -ss to start extracting from a certain point in time.

For creating a video from many images:
@example
avconv -f image2 -i foo-%03d.jpeg -r 12 -s WxH foo.avi
@end example

The syntax @code{foo-%03d.jpeg} specifies to use a decimal number
composed of three digits padded with zeroes to express the sequence
number. It is the same syntax supported by the C printf function, but
only formats accepting a normal integer are suitable.

@item
You can put many streams of the same type in the output:

@example
avconv -i test1.avi -i test2.avi -map 1:1 -map 1:0 -map 0:1 -map 0:0 -c copy -y test12.nut
@end example

The resulting output file @file{test12.nut} will contain the first four streams
from the input files in reverse order.

@item
To force CBR video output:
@example
avconv -i myfile.avi -b 4000k -minrate 4000k -maxrate 4000k -bufsize 1835k out.m2v
@end example

@item
The four options lmin, lmax, mblmin and mblmax use 'lambda' units,
but you may use the QP2LAMBDA constant to easily convert from 'q' units:
@example
avconv -i src.ext -lmax 21*QP2LAMBDA dst.ext
@end example

@end itemize
@c man end EXAMPLES

@include eval.texi
@include decoders.texi
@include encoders.texi
@include demuxers.texi
@include muxers.texi
@include indevs.texi
@include protocols.texi
@include bitstream_filters.texi
@include filters.texi
@include metadata.texi

@ignore

@setfilename avconv
@settitle avconv video converter

@c man begin SEEALSO
avplay(1), avprobe(1) and the Libav HTML documentation
@c man end

@c man begin AUTHORS
The Libav developers
@c man end

@end ignore

@bye
